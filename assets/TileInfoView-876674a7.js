import{bF as Y,lk as P,cL as z}from"./index-0199b717.js";var R,v,y,B,N,p,x;(function(o){o[o.FILL=0]="FILL",o[o.LINE=1]="LINE",o[o.MARKER=2]="MARKER",o[o.TEXT=3]="TEXT",o[o.LABEL=4]="LABEL"})(R||(R={})),function(o){o[o.NONE=0]="NONE",o[o.MAP=1]="MAP",o[o.LABEL=2]="LABEL",o[o.LABEL_ALPHA=4]="LABEL_ALPHA",o[o.HITTEST=8]="HITTEST",o[o.HIGHLIGHT=16]="HIGHLIGHT",o[o.CLIP=32]="CLIP",o[o.DEBUG=64]="DEBUG",o[o.NUM_DRAW_PHASES=9]="NUM_DRAW_PHASES"}(v||(v={})),function(o){o[o.SIZE=0]="SIZE",o[o.COLOR=1]="COLOR",o[o.OPACITY=2]="OPACITY",o[o.ROTATION=3]="ROTATION"}(y||(y={})),function(o){o[o.NONE=0]="NONE",o[o.OPACITY=1]="OPACITY",o[o.COLOR=2]="COLOR",o[o.ROTATION=4]="ROTATION",o[o.SIZE_MINMAX_VALUE=8]="SIZE_MINMAX_VALUE",o[o.SIZE_SCALE_STOPS=16]="SIZE_SCALE_STOPS",o[o.SIZE_FIELD_STOPS=32]="SIZE_FIELD_STOPS",o[o.SIZE_UNIT_VALUE=64]="SIZE_UNIT_VALUE"}(B||(B={})),function(o){o[o.MINMAX_TARGETS_OUTLINE=128]="MINMAX_TARGETS_OUTLINE",o[o.SCALE_TARGETS_OUTLINE=256]="SCALE_TARGETS_OUTLINE",o[o.FIELD_TARGETS_OUTLINE=512]="FIELD_TARGETS_OUTLINE",o[o.UNIT_TARGETS_OUTLINE=1024]="UNIT_TARGETS_OUTLINE"}(N||(N={})),function(o){o[o.SPRITE=0]="SPRITE",o[o.GLYPH=1]="GLYPH"}(p||(p={})),function(o){o[o.DEFAULT=0]="DEFAULT",o[o.SIMPLE=1]="SIMPLE",o[o.DOT_DENSITY=2]="DOT_DENSITY",o[o.OUTLINE_FILL=3]="OUTLINE_FILL",o[o.OUTLINE_FILL_SIMPLE=4]="OUTLINE_FILL_SIMPLE",o[o.HEATMAP=5]="HEATMAP",o[o.PIE_CHART=6]="PIE_CHART"}(x||(x={}));class C{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,l){const{spans:e,lodInfo:i}=this,{level:s}=i;if(e.length!==0)for(const{row:h,colFrom:r,colTo:n}of e)for(let a=r;a<=n;a++)t.call(l,s,h,i.normalizeCol(a),i.getWorldForColumn(a))}}C.pool=new Y(C);function M(o,t){return[o,t]}function w(o,t,l){return o[0]=t,o[1]=l,o}function D(o,t,l,e,i){return o[0]=t,o[1]=l,o[2]=e,o[3]=i,o}const d=new P("0/0/0/0");let H=class U{static create(t,l,e=null){const i=z(t.spatialReference),s=l.origin||M(t.origin.x,t.origin.y),h=M(t.size[0]*l.resolution,t.size[1]*l.resolution),r=M(-1/0,-1/0),n=M(1/0,1/0),a=M(1/0,1/0);e!=null&&(w(r,Math.max(0,Math.floor((e.xmin-s[0])/h[0])),Math.max(0,Math.floor((s[1]-e.ymax)/h[1]))),w(n,Math.max(0,Math.floor((e.xmax-s[0])/h[0])),Math.max(0,Math.floor((s[1]-e.ymin)/h[1]))),w(a,n[0]-r[0]+1,n[1]-r[1]+1));const{cols:c,rows:T}=l;let m,A,S,I;return!e&&c&&T&&(w(r,c[0],T[0]),w(n,c[1],T[1]),w(a,c[1]-c[0]+1,T[1]-T[0]+1)),t.isWrappable?(m=M(Math.ceil(Math.round((i.valid[1]-i.valid[0])/l.resolution)/t.size[0]),a[1]),A=M(Math.floor((i.origin[0]-s[0])/h[0]),r[1]),S=M(m[0]+A[0]-1,n[1]),I=!0):(A=r,S=n,m=a,I=!1),new U(l.level,l.resolution,l.scale,s,r,n,a,h,A,S,m,I)}constructor(t,l,e,i,s,h,r,n,a,c,T,m){this.level=t,this.resolution=l,this.scale=e,this.origin=i,this.first=s,this.last=h,this.size=r,this.norm=n,this.worldStart=a,this.worldEnd=c,this.worldSize=T,this.wrap=m}normalizeCol(t){if(!this.wrap)return t;const l=this.worldSize[0];return t<0?l-1-Math.abs((t+1)%l):t%l}denormalizeCol(t,l){return this.wrap?this.worldSize[0]*l+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,l,e=!1){d.set(l);const i=e?d.col:this.denormalizeCol(d.col,d.world),s=d.row;return D(t,this.getXForColumn(i),this.getYForRow(s+1),this.getXForColumn(i+1),this.getYForRow(s)),t}getTileCoords(t,l,e=!1){d.set(l);const i=e?d.col:this.denormalizeCol(d.col,d.world);return Array.isArray(t)?w(t,this.getXForColumn(i),this.getYForRow(d.row)):(t.x=this.getXForColumn(i),t.y=this.getYForRow(d.row)),t}};class F{constructor(t,l,e){this.row=t,this.colFrom=l,this.colTo=e}}const u=new P("0/0/0/0");class O{static create(t,l){t[1]>l[1]&&([t,l]=[l,t]);const[e,i]=t,[s,h]=l,r=s-e,n=h-i,a=n!==0?r/n:0,c=(Math.ceil(i)-i)*a,T=(Math.floor(i)-i)*a;return new O(e,Math.floor(i),Math.ceil(h),a,r<0?c:T,r<0?T:c,r<0?s:e,r<0?e:s)}constructor(t,l,e,i,s,h,r,n){this.x=t,this.ymin=l,this.ymax=e,this.invM=i,this.leftAdjust=s,this.rightAdjust=h,this.leftBound=r,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const _=[[0,0],[0,0],[0,0],[0,0]],X=1e-6;class E{constructor(t,l=null,e=t.lods[0].level,i=t.lods[t.lods.length-1].level){this.tileInfo=t,this.fullExtent=l,this.scales=[],this._infoByScale={},this._infoByLevel={};const s=t.lods.filter(r=>r.level>=e&&r.level<=i);this.minScale=s[0].scale,this.maxScale=s[s.length-1].scale;const h=this._lodInfos=s.map(r=>H.create(t,r,l));s.forEach((r,n)=>{this._infoByLevel[r.level]=h[n],this._infoByScale[r.scale]=h[n],this.scales[n]=r.scale},this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel[typeof t=="number"?t:t.level]}getTileBounds(t,l,e=!1){u.set(l);const i=this._infoByLevel[u.level];return i?i.getTileBounds(t,u,e):t}getTileCoords(t,l,e=!1){u.set(l);const i=this._infoByLevel[u.level];return i?i.getTileCoords(t,u,e):t}getTileCoverage(t,l=192,e=!0,i="closest"){if(!e&&(t.scale>this.minScale||t.scale<this.maxScale))return null;const s=i==="closest"?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),h=C.pool.acquire(s),r=this._wrap;let n,a,c,T=1/0,m=-1/0;const A=h.spans;_[0][0]=_[0][1]=_[1][1]=_[3][0]=-l,_[1][0]=_[2][0]=t.size[0]+l,_[2][1]=_[3][1]=t.size[1]+l;for(const f of _)t.toMap(f,f),f[0]=s.getColumnForX(f[0]),f[1]=s.getRowForY(f[1]);const S=[];let I=3;for(let f=0;f<4;f++){if(_[f][1]===_[I][1]){I=f;continue}const L=O.create(_[f],_[I]);T=Math.min(L.ymin,T),m=Math.max(L.ymax,m),S[L.ymin]===void 0&&(S[L.ymin]=[]),S[L.ymin].push(L),I=f}if(T==null||m==null||m-T>100)return null;let g=[];for(n=T;n<m;){S[n]!=null&&(g=g.concat(S[n])),a=1/0,c=-1/0;for(let f=g.length-1;f>=0;f--){const L=g[f];a=Math.min(a,L.getLeftCol()),c=Math.max(c,L.getRightCol())}if(a=Math.floor(a),c=Math.floor(c),n>=s.first[1]&&n<=s.last[1])if(r)if(s.size[0]<s.worldSize[0]){const f=Math.floor(c/s.worldSize[0]);for(let L=Math.floor(a/s.worldSize[0]);L<=f;L++)A.push(new F(n,Math.max(s.getFirstColumnForWorld(L),a),Math.min(s.getLastColumnForWorld(L),c)))}else A.push(new F(n,a,c));else a>s.last[0]||c<s.first[0]||(a=Math.max(a,s.first[0]),c=Math.min(c,s.last[0]),A.push(new F(n,a,c)));n+=1;for(let f=g.length-1;f>=0;f--){const L=g[f];L.ymax>=n?L.incrRow():g.splice(f,1)}}return h}getTileParentId(t){u.set(t);const l=this._infoByLevel[u.level],e=this._lodInfos.indexOf(l)-1;return e<0?null:(this._getTileIdAtLOD(u,this._lodInfos[e],u),u.id)}getTileResolution(t){const l=this._infoByLevel[typeof t=="object"?t.level:t];return l?l.resolution:-1}getTileScale(t){const l=this._infoByLevel[t.level];return l?l.scale:-1}intersects(t,l){u.set(l);const e=this._infoByLevel[u.level],i=t.lodInfo;if(i.resolution>e.resolution){this._getTileIdAtLOD(u,i,u);const h=i.denormalizeCol(u.col,u.world);for(const r of t.spans)if(r.row===u.row&&r.colFrom<=h&&r.colTo>=h)return!0}if(i.resolution<e.resolution){const[h,r,n,a]=t.spans.reduce((I,g)=>(I[0]=Math.min(I[0],g.row),I[1]=Math.max(I[1],g.row),I[2]=Math.min(I[2],g.colFrom),I[3]=Math.max(I[3],g.colTo),I),[1/0,-1/0,1/0,-1/0]),c=e.denormalizeCol(u.col,u.world),T=i.getColumnForX(e.getXForColumn(c)),m=i.getRowForY(e.getYForRow(u.row)),A=i.getColumnForX(e.getXForColumn(c+1))-1,S=i.getRowForY(e.getYForRow(u.row+1))-1;return!(T>a||A<n||m>r||S<h)}const s=i.denormalizeCol(u.col,u.world);return t.spans.some(h=>h.row===u.row&&h.colFrom<=s&&h.colTo>=s)}normalizeBounds(t,l,e){if(t[0]=l[0],t[1]=l[1],t[2]=l[2],t[3]=l[3],this._wrap){const i=z(this.tileInfo.spatialReference),s=-e*(i.valid[1]-i.valid[0]);t[0]+=s,t[2]+=s}return t}getSmallestInfoForScale(t){const l=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>l[0])return this._infoByScale[l[0]];for(let e=1;e<l.length-1;e++)if(t>l[e]+X)return this._infoByScale[l[e-1]];return this._infoByScale[l[l.length-1]]}getClosestInfoForScale(t){const l=this.scales;return this._infoByScale[t]||(t=l.reduce((e,i)=>Math.abs(i-t)<Math.abs(e-t)?i:e,l[0])),this._infoByScale[t]}scaleToLevel(t){const l=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let e=l.length-1;e>=0;e--)if(t<l[e])return e===l.length-1?this._infoByScale[l[l.length-1]].level:this._infoByScale[l[e]].level+(l[e]-t)/(l[e]-l[e+1]);return this._infoByScale[l[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,l,e){const i=this._infoByLevel[e.level];return t.set(e),l.resolution<i.resolution?null:(l.resolution===i.resolution||(t.level=l.level,t.col=Math.floor(e.col*i.resolution/l.resolution+.01),t.row=Math.floor(e.row*i.resolution/l.resolution+.01)),t)}}export{N as A,R as E,B as L,x as S,v as T,E as h,C as l};
