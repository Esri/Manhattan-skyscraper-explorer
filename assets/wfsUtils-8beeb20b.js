import{bo as T,gK as v,ai as c,gL as D,gM as x,gN as C,gO as S,bD as E,c5 as U,cF as M,dR as w,f7 as O,df as I,am as L,fg as y,f9 as j}from"./index-0199b717.js";import{s as V}from"./geojson-774c2352.js";import{o as h,n as b}from"./xmlUtils-444cb4c0.js";function W(n){return z(n)??X(n)}function X(n){const t=new Date(n).getTime();return Number.isNaN(t)?null:t}function z(n){const t=Y.exec(n);if(!t?.groups)return null;const e=t.groups,r=+e.year,s=+e.month-1,a=+e.day,o=+(e.hours??"0"),i=+(e.minutes??"0"),u=+(e.seconds??"0");if(o>23||i>59||u>59)return null;const p=e.ms??"0",l=p?+p.padEnd(3,"0").substring(0,3):0;let m;if(e.isUTC)m=Date.UTC(r,s,a,o,i,u,l);else if(e.offsetSign){const f=+e.offsetHours,G=+e.offsetMinutes;m=6e4*(e.offsetSign==="+"?-1:1)*(60*f+G)+Date.UTC(r,s,a,o,i,u,l)}else m=new Date(r,s,a,o,i,u,l).getTime();return Number.isNaN(m)?null:m}const Y=/^(?:(?<year>-?\d{4,})-(?<month>\d{2})-(?<day>\d{2}))(?:T(?<hours>\d{2}):(?<minutes>\d{2}):(?<seconds>\d{2})(?:\.(?<ms>\d+))?)?(?:(?<isUTC>Z)|(?:(?<offsetSign>\+|-)(?<offsetHours>\d{2}):(?<offsetMinutes>\d{2})))?$/,F="xlink:href",d="2.0.0",N="__esri_wfs_id__",q="wfs-layer:getWFSLayerTypeInfo-error",_="wfs-layer:empty-service",$="wfs-layer:feature-type-not-found",H="wfs-layer:geojson-not-supported",J="wfs-layer:kvp-encoding-not-supported",Q="wfs-layer:malformed-json",P="wfs-layer:unknown-geometry-type",B="wfs-layer:unknown-field-type",K="wfs-layer:unsupported-spatial-reference",Z="wfs-layer:unsupported-wfs-version";async function he(n,t){const e=ee((await T(n,{responseType:"text",query:{SERVICE:"WFS",REQUEST:"GetCapabilities",VERSION:d,...t?.customParameters},signal:t?.signal})).data);return re(n,e),e}function ee(n){const t=A(n);ge(t),k(t);const e=t.firstElementChild,r=v(ae(e));return{operations:ne(e),get featureTypes(){return Array.from(r())},readFeatureTypes:r}}const te=new Set(["json","application/json","geojson","application/json; subtype=geojson"]);function ne(n){let t=!1;const e={GetCapabilities:{url:""},DescribeFeatureType:{url:""},GetFeature:{url:"",outputFormat:null,supportsPagination:!1}};if(h(n,{OperationsMetadata:{Operation:r=>{switch(r.getAttribute("name")){case"GetCapabilities":return{DCP:{HTTP:{Get:s=>{e.GetCapabilities.url=s.getAttribute(F)}}}};case"DescribeFeatureType":return{DCP:{HTTP:{Get:s=>{e.DescribeFeatureType.url=s.getAttribute(F)}}}};case"GetFeature":return{DCP:{HTTP:{Get:s=>{e.GetFeature.url=s.getAttribute(F)}}},Parameter:s=>{if(s.getAttribute("name")==="outputFormat")return{AllowedValues:{Value:a=>{const o=a.textContent;o&&te.has(o.toLowerCase())&&(e.GetFeature.outputFormat=o)}}}}}}},Constraint:r=>{switch(r.getAttribute("name")){case"KVPEncoding":return{DefaultValue:s=>{t=s.textContent.toLowerCase()==="true"}};case"ImplementsResultPaging":return{DefaultValue:s=>{e.GetFeature.supportsPagination=s.textContent.toLowerCase()==="true"}}}}}}),!t)throw new c(J,"WFS service doesn't support key/value pair (KVP) encoding");if(e.GetFeature.outputFormat==null)throw new c(H,"WFS service doesn't support GeoJSON output format");return e}function re(n,t){D(n)&&(x(n,t.operations.DescribeFeatureType.url,!0)&&(t.operations.DescribeFeatureType.url=C(t.operations.DescribeFeatureType.url)),x(n,t.operations.GetFeature.url,!0)&&(t.operations.GetFeature.url=C(t.operations.GetFeature.url)))}function ae(n){return b(n,{FeatureTypeList:{FeatureType:t=>{const e={typeName:"undefined:undefined",name:"",title:"",description:"",extent:null,namespacePrefix:"",namespaceUri:"",supportedSpatialReferences:[]},r=new Set([4326]),s=a=>{const o=parseInt(a.textContent?.match(/(?<wkid>\d+$)/i)?.groups?.wkid??"",10);Number.isNaN(o)||r.add(o)};return h(t,{Name:a=>{const{name:o,prefix:i}=g(a.textContent);e.typeName=`${i}:${o}`,e.name=o,e.namespacePrefix=i,e.namespaceUri=a.lookupNamespaceURI(i)},Abstract:a=>{e.description=a.textContent},Title:a=>{e.title=a.textContent},WGS84BoundingBox:a=>{e.extent=se(a)},DefaultSRS:s,DefaultCRS:s,OtherSRS:s,OtherCRS:s}),e.title||(e.title=e.name),e.supportedSpatialReferences.push(...r),e}}})}function se(n){let t,e,r,s;for(const a of n.children)switch(a.localName){case"LowerCorner":[t,e]=a.textContent.split(" ").map(o=>Number.parseFloat(o));break;case"UpperCorner":[r,s]=a.textContent.split(" ").map(o=>Number.parseFloat(o))}return{xmin:t,ymin:e,xmax:r,ymax:s,spatialReference:w}}function oe(n,t,e){return S(n,r=>e?r.name===t&&r.namespaceUri===e:r.typeName===t||r.name===t)}async function Fe(n,t,e,r={}){const{featureType:s,extent:a}=await ie(n,t,e,r),{fields:o,geometryType:i,swapXY:u,objectIdField:p,geometryField:l}=await ue(n,s.typeName,r);return{url:n.operations.GetCapabilities.url,name:s.name,namespaceUri:s.namespaceUri,fields:o,geometryField:l,geometryType:i,objectIdField:p,spatialReference:r.spatialReference??E.WGS84,extent:a,swapXY:u,wfsCapabilities:n,customParameters:r.customParameters}}async function ie(n,t,e,r={}){const{spatialReference:s=E.WGS84}=r,a=n.readFeatureTypes(),o=t?oe(a,t,e):a.next().value;if(o==null)throw t?new c($,`The type '${t}' could not be found in the service`):new c(_,"The service is empty");let i=new U({...o.extent,spatialReference:s});if(!M(s,w))try{await O(w,s,void 0,r),i=I(i,w)}catch{throw new c(K,"Projection not supported")}return{extent:i,spatialReference:s,featureType:o}}async function ue(n,t,e={}){const[r,s]=await L([ce(n.operations.DescribeFeatureType.url,t,e),le(n,t,e)]);if(r.error||s.error)throw new c(q,`An error occurred while getting info about the feature type '${t}'`,{error:r.error||s.error});const{fields:a,errors:o}=r.value??{},i=r.value?.geometryType||s.value?.geometryType,u=s.value?.swapXY??!1;if(i==null)throw new c(P,`The geometry type could not be determined for type '${t}`,{typeName:t,geometryType:i,fields:a,errors:o});return{...pe(a??[]),geometryType:i,swapXY:u}}function pe(n){const t=n.find(r=>r.type==="geometry");let e=n.find(r=>r.type==="oid");return n=n.filter(r=>r.type!=="geometry"),e||(e=new y({name:N,type:"oid",alias:N}),n.unshift(e)),{geometryField:t?.name??null,objectIdField:e.name,fields:n}}async function le(n,t,e={}){let r,s=!1;const[a,o]=await Promise.all([de(n.operations.GetFeature.url,t,n.operations.GetFeature.outputFormat,{...e,count:1}),T(n.operations.GetFeature.url,{responseType:"text",query:R(t,void 0,{...e,count:1}),signal:e?.signal})]),i=a.type==="FeatureCollection"&&a.features[0]?.geometry;if(i){let u;switch(r=j.fromJSON(V(i.type)),i.type){case"Point":u=i.coordinates;break;case"LineString":case"MultiPoint":u=i.coordinates[0];break;case"MultiLineString":case"Polygon":u=i.coordinates[0][0];break;case"MultiPolygon":u=i.coordinates[0][0][0]}const p=/<[^>]*pos[^>]*> *(-?\d+(?:\.\d+)?) (-?\d+(?:\.\d+)?)/.exec(o.data);if(p){const l=u[0].toFixed(3),m=u[1].toFixed(3),f=parseFloat(p[1]).toFixed(3);l===parseFloat(p[2]).toFixed(3)&&m===f&&(s=!0)}}return{geometryType:r,swapXY:s}}async function ce(n,t,e){return me(t,(await T(n,{responseType:"text",query:{SERVICE:"WFS",REQUEST:"DescribeFeatureType",VERSION:d,TYPENAME:t,...e?.customParameters},signal:e?.signal})).data)}function me(n,t){const{name:e}=g(n),r=A(t);k(r);const s=S(b(r.firstElementChild,{element:a=>({name:a.getAttribute("name"),typeName:g(a.getAttribute("type")).name})}),({name:a})=>a===e);if(s!=null){const a=S(b(r.firstElementChild,{complexType:o=>o}),o=>o.getAttribute("name")===s.typeName);if(a!=null)return fe(a)}throw new c($,`Type '${n}' not found in document`,{document:new XMLSerializer().serializeToString(r)})}const ye=new Set(["objectid","fid"]);function fe(n){const t=[],e=[];let r;const s=b(n,{complexContent:{extension:{sequence:{element:a=>a}}}});for(const a of s){const o=a.getAttribute("name");if(!o)continue;let i,u;if(a.hasAttribute("type")?i=g(a.getAttribute("type")).name:h(a,{simpleType:{restriction:m=>(i=g(m.getAttribute("base")).name,{maxLength:f=>{u=+f.getAttribute("value")}})}}),!i)continue;const p=a.getAttribute("nillable")==="true";let l=!1;switch(i.toLowerCase()){case"integer":case"nonpositiveinteger":case"negativeinteger":case"long":case"int":case"short":case"byte":case"nonnegativeinteger":case"unsignedlong":case"unsignedint":case"unsignedshort":case"unsignedbyte":case"positiveinteger":e.push(new y({name:o,alias:o,type:"integer",nullable:p}));break;case"float":case"double":case"decimal":e.push(new y({name:o,alias:o,type:"double",nullable:p}));break;case"boolean":case"string":case"gyearmonth":case"gyear":case"gmonthday":case"gday":case"gmonth":case"anyuri":case"qname":case"notation":case"normalizedstring":case"token":case"language":case"idrefs":case"entities":case"nmtoken":case"nmtokens":case"name":case"ncname":case"id":case"idref":case"entity":case"duration":case"time":e.push(new y({name:o,alias:o,type:"string",nullable:p,length:u??255}));break;case"datetime":case"date":e.push(new y({name:o,alias:o,type:"date",nullable:p,length:u??36}));break;case"pointpropertytype":r="point",l=!0;break;case"multipointpropertytype":r="multipoint",l=!0;break;case"curvepropertytype":case"multicurvepropertytype":case"multilinestringpropertytype":r="polyline",l=!0;break;case"surfacepropertytype":case"multisurfacepropertytype":case"multipolygonpropertytype":r="polygon",l=!0;break;case"geometrypropertytype":case"multigeometrypropertytype":l=!0,t.push(new c(P,`geometry type '${i}' is not supported`,{type:new XMLSerializer().serializeToString(n)}));break;default:t.push(new c(B,`Unknown field type '${i}'`,{type:new XMLSerializer().serializeToString(n)}))}l&&e.push(new y({name:o,alias:o,type:"geometry",nullable:p}))}for(const a of e)if(a.type==="integer"&&!a.nullable&&ye.has(a.name.toLowerCase())){a.type="oid";break}return{geometryType:r,fields:e,errors:t}}async function de(n,t,e,r){let{data:s}=await T(n,{responseType:"text",query:R(t,e,r),signal:r?.signal});s=s.replaceAll(/": +(-?\d+),(\d+)(,)?/g,'": $1.$2$3');try{if(r?.dateFields?.length){const a=new Set(r.dateFields);return JSON.parse(s,(o,i)=>a.has(o)?W(i):i)}return JSON.parse(s)}catch(a){throw new c(Q,"Error while parsing theÂ response",{response:s,error:a})}}function R(n,t,e){return{SERVICE:"WFS",REQUEST:"GetFeature",VERSION:d,TYPENAMES:n,OUTPUTFORMAT:t,SRSNAME:"EPSG:4326",STARTINDEX:e?.startIndex,COUNT:e?.count,...e?.customParameters}}function A(n){return new DOMParser().parseFromString(n.trim(),"text/xml")}function g(n){const[t,e]=n.split(":");return{prefix:e?t:"",name:e??t}}function ge(n){const t=n.firstElementChild?.getAttribute("version");if(t&&t!==d)throw new c(Z,`Unsupported WFS version ${t}. Supported version: ${d}`)}function k(n){let t="",e="";if(h(n.firstElementChild,{Exception:r=>(t=r.getAttribute("exceptionCode"),{ExceptionText:s=>{e=s.textContent}})}),t)throw new c(`wfs-layer:${t}`,e)}export{de as H,oe as M,N as S,Fe as V,pe as Y,he as v};
