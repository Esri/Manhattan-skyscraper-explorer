import{b1 as I,aL as b,at as S,ds as v,dt as w,cc as h,ce as m}from"./index-112c244d.js";import{t as d,r as O}from"./fetchService-21f7bf3b.js";import{a as L}from"./lazyLayerLoader-8f831dc7.js";const P={FeatureLayer:!0,SceneLayer:!0};async function _(r){const l=r.properties?.customParameters,e=await g(r.url,l),a={...r.properties,url:r.url};if(!e.sublayerIds)return e.layerOrTableId!=null&&(a.layerId=e.layerOrTableId,a.sourceJSON=e.sourceJSON),new e.Constructor(a);const t=new(await I(()=>import("./GroupLayer-ffdc99cd.js"),["./GroupLayer-ffdc99cd.js","./index-112c244d.js","./index-a616bda8.css","./lazyLayerLoader-8f831dc7.js"],import.meta.url)).default({title:e.parsedUrl.title});return T(t,e,a),t}function p(r,l){return r?r.find(e=>e.id===l):null}function T(r,l,e){function a(t,s){const o={...e,layerId:t,sublayerTitleMode:"service-name"};return s!=null&&(o.sourceJSON=s),new l.Constructor(o)}l.sublayerIds.forEach(t=>{const s=a(t,p(l.sublayerInfos,t));r.add(s)}),l.tableIds.forEach(t=>{const s=a(t,p(l.tableInfos,t));r.tables.add(s)})}async function g(r,l){let e=b(r);if(e==null&&(e=await C(r,l)),e==null)throw new S("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:r});const{serverType:a,sublayer:t}=e;let s;const o={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(a){case"MapServer":t!=null?s="FeatureLayer":s=await $(r,l)?"TileLayer":"MapImageLayer";break;case"ImageServer":{const n=await d(r,{customParameters:l}),{tileInfo:y,cacheType:i}=n;s=y?y?.format?.toUpperCase()!=="LERC"||i&&i.toLowerCase()!=="elevation"?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const n=await d(e.url.path,{customParameters:l});if(s="SceneLayer",n){const y=n?.layers;if(n?.layerType==="Voxel")s="VoxelLayer";else if(y?.length){const i=y[0]?.layerType;i!=null&&m[i]!=null&&(s=m[i])}}break}default:s=o[a]}const u=a==="FeatureServer",c={parsedUrl:e,Constructor:null,layerOrTableId:u?t:void 0,sublayerIds:null,tableIds:null};if(P[s]&&t==null){const n=await F(r,a,l);u&&(c.sublayerInfos=n.layerInfos,c.tableInfos=n.tableInfos),n.layerIds.length+n.tableIds.length!==1?(c.sublayerIds=n.layerIds,c.tableIds=n.tableIds):u&&(c.layerOrTableId=n.layerIds[0]??n.tableIds[0],c.sourceJSON=n.layerInfos?.[0]??n.tableInfos?.[0])}return c.Constructor=await N(s),c}async function C(r,l){const e=await d(r,{customParameters:l});let a=null,t=null;const s=e.type;if(s==="Feature Layer"||s==="Table"?(a="FeatureServer",t=e.id??null):s==="indexedVector"?a="VectorTileServer":e.hasOwnProperty("mapName")?a="MapServer":e.hasOwnProperty("bandCount")&&e.hasOwnProperty("pixelSizeX")?a="ImageServer":e.hasOwnProperty("maxRecordCount")&&e.hasOwnProperty("allowGeometryUpdates")?a="FeatureServer":e.hasOwnProperty("streamUrls")?a="StreamServer":f(e)?(a="SceneServer",t=e.id):e.hasOwnProperty("layers")&&f(e.layers?.[0])&&(a="SceneServer"),!a)return null;const o=t!=null?v(r):null;return{title:o!=null&&e.name||w(r),serverType:a,sublayer:t,url:{path:o!=null?o.serviceUrl:h(r).path}}}function f(r){return r!=null&&r.hasOwnProperty("store")&&r.hasOwnProperty("id")&&typeof r.id=="number"}async function F(r,l,e){let a,t=!1;if(l==="FeatureServer"){const u=await O(r,{customParameters:e});t=!!u.layersJSON,a=u.layersJSON||u.serviceJSON}else a=await d(r,{customParameters:e});const s=a?.layers,o=a?.tables;return{layerIds:s?.map(u=>u.id).reverse()||[],tableIds:o?.map(u=>u.id).reverse()||[],layerInfos:t?s:[],tableInfos:t?o:[]}}async function N(r){return(0,L[r])()}async function $(r,l){return(await d(r,{customParameters:l})).tileInfo}export{_ as fromUrl};
